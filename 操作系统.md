### 进程的概念
程序是静态的，只是一个存放在磁盘里面的可执行文件，是一系列指令的集合。
而进程是动态的，是程序的一次执行过程。
**同一个程序的多次执行对应着的是多个进程**
那么操作系统如何来区分同一个程序的多个进程呢？解决方案是，当一个进程被创建的时候，操作系统会为该进程分配一个唯一的、不重复的 PID  。（现在小杜知道传输层之间通信时，数据报是如何精准地仅靠 socket 就发送到接收端的进程了的。）除了用来区分进程的 PID ，操作系统还会记录进程所属的用户 UID 、记录给进程分配了哪些资源。这些信息都被保存在一个数据结构**进程控制块PCB**中。
因此，**PCB是进程存在的唯一标志**。当进程被创建时，操作系统会为其创建PCB；当进程结束时，操作系统会回收其PCB。

### 进程的组成
一个进程可以视为由以下三个部分组成。
|--|--|
|--|--|
|PCB|给操作系统用的，包含操作系统内记录的进程信息|
|程序段|给进程自己使用，包含程序指令|
|数据段|给进程自己使用，包含运行过程中产生的各种数据|

进程是能独立运行、独立获得资源、独立接收调度的基本单位。

### 进程的状态
|--|--|
|--|--|
|创建态|当进程正在被创建时所处的状态，此时操作系统会为进程分配资源、初始化PCB|
|就绪态|当进程创建完成后所处的状态，此时进程已经具备运行条件，但是由于CPU不空闲而暂时不能执行|
|运行态|当一个进程在CPU上运行时所处的状态，此时CPU会执行该进程对应的指令序列|
|阻塞态|当运行中的进程遇到等待某个资源或输入时，此时操作系统会让这个进程下CPU，并进入阻塞态；当它等待的东西到了，它就会再次进入就绪态|
|终止态|当进程运行结束时会发出exit系统调用，此时进程进入终止态，操作系统对该进程同时执行下CPU、回收空间内存、回收PCB等工作|

运行态到阻塞态是进程自身做出的主动行为。
**阻塞态只能从运行态转换得到，阻塞态的下一个状态一定是就绪态**。当运行时间片用完，进程也可以从运行态转换为就绪态。
单个 CPU 的进程中，同一时刻只会有一个进程处于运行态。
在进程 PCB 中，会有一个变量 state 来表示进程的当前状态。



### 原语
原语是一种特殊的程序，它的执行具有原子性。即这个程序的运行必须一次性运行完毕，不可以被中断。
那么是如何实现原子性的呢？原理是使用了两个特权指令————关中断和开中断。

### 进程控制
进程控制就是要实现进程状态转换。
在实现进程控制的过程中，必须用原语实现，也就是必须一次性运行完毕。
当一个进程下 CPU 的时候，会把自己的运行环境信息（包括必要的寄存器信息）保留在自己的 PCB 当中。
进程控制原语概述：首先更新 PCB 中的信息，然后将 PCB 插入合适的队列，最后分配或回收资源。

#### 进程的创建
使用的原语是创建原语，这期间要完成的事情是：
1. 申请空白 PCB
2. 为新进程分配所需的资源
3. 初始化 PCB
4. 将 PCB插入就绪队列，此时进程从创建态来到了就绪态。

#### 进程的终止
使用的原语是终止原语，这期间要完成的事情是：
1. 从 PCB 集合中找到终止进程的 PCB
2. 若进程正在运行，则立刻把该进程下 CPU ，将 CPU 分配给其他进程
3. 终止这个进程的所有子进程
4. 将该进程拥有的所有资源归还给父进程or操作系统
5. 删除 PCB

#### 进程的阻塞
使用的原语是阻塞原语，这期间要完成的事情是：
1. 从 PCB 集合中找到要阻塞的进程的 PCB
2. 保护进程运行现场，将其 PCB 状态信息设置为阻塞态，暂时停止进程运行
3. 将 PCB 插入相应事件的等待队列

#### 进程的唤醒
使用的原语是唤醒原语，这期间要完成的事情是：
1. 从 PCB 集合中找到要唤醒的进程的 PCB
2. 将 PCB 从等待队列中移除，设置进程为就绪态
3. 将 PCB 插入就绪队列，等待被调度

#### 进程的切换
使用的原语是切换原语，这期间要完成的事情是：
1. 将运行环境信息存入旧进程的 PCB
2. 将旧 PCB 移入相应就绪队列
3. 选择另一个进程来执行，并更新其 PCB
4. 根据新进程的 PCB 内的运行环境信息恢复新进程所需的运行环境


### 进程通信
进程通信指的是两个进程之间产生数据交互。
为何进程的通信需要操作系统支持呢？因为各进程拥有的内存地址空间相互独立，其他进程不能读取或修改其他进程的地址空间在，这是为了保证安全。


#### 共享存储
实现原理：进程还是有一个不能被其他进程访问的内存地址空间，但是每个进程都可以申请一个可以被其他进程访问的共享存储区，把需要通信的数据写到共享存储区内就可以被其他进程读取了。
**各个进程对共享空间的访问应该是互斥的**
两种实现方式：
1. 基于存储区实现，数据由通信进程控制，速度很快
2. 基于数据结构实现，比如共享空间里只能放一个固定长度的数组，这样的方式速度慢、限制多


#### 消息传递
实现原理：数据以格式化的消息为单位，通过操作系统提供的原语“发送消息”“接收消息”来实现。
两种实现方式：
1. 直接通信：发送消息的进程要**直接指明接收消息的进程的 PID** ，操作系统接收到之后把消息复制到位于内核空间里面的接收信息进程的消息队列里面，接收消息的进程也要指明自己是接收来自哪个进程的消息。
2. 间接通信：发送端先在内存中申请一块空间“信箱”，打包完消息后**指明的是消息要发往的信箱，而不是要发往的接收端进程的 PID** 。接收端也是指明自己要接收的消息来自哪个信箱。


#### 管道通信
“管道”是一个特殊的共享文件即 pipe 文件。其实就是在内存中开辟一个大小固定的内存缓冲区。
与共享存储的区别在于：管道类似于一个循环队列，先被发送端扔进管道的数据会先被接收端拿到，且某一时段内数据只能单向流动。
各个进程对管道的访问也是互斥的，**管道塞满数据时——写进程阻塞，管道没有数据时——读进程阻塞**。
|--|--|
|--|--|
|半双工通信|管道在一个时间段内只能实现单向的传输，尽管方向可以改变|
|全双工通信|双向可以同时通信的传输|

Linux系统处理管道通信：允许一个管道有多个写进程和多个读进程，但是操作系统会让各个读进程轮流从管道中读取数据。


### 线程的由来
有的进程可能需要同时做很多事情，而传统的进程只能**串行**地执行一系列程序，完成的功能固定且单一。因此引入线程来增加并发度。一个进程之中可能包含多个线程。
本来只是各进程可以并发，进程内部还是串行执行；现在进程内部的线程也可以并发，使得一个进程内也可以并发处理各种任务（如微信聊天、语音通话、听歌同时执行）。
**引入线程后， CPU 调度和服务的对象就变成了线程，线程成了程序执行流的最小单位**。


### 引入线程之后的不同

|--|--|--|
|--|--|--|
|方面|传统进程机制|引入线程后|
|资源分配调度|进程是资源分配、调度的基本单位|进程是资源分配的基本单位，线程是调度的基本单位|
|并发性|只能进程之间并发|各线程之间也能并发|
|系统开销|每次需要切换进程的运行环境，系统开销很大|若是同一进程内的线程切换，则不需要切换进程环境，系统开销减小|


### 线程的属性
1. 线程是系统调度的基本单位
2. 多 CPU 计算机中，各线程可以占用不同的 CPU
3. 每个线程都有一个线程 ID ，线程控制块 TCB
4. 线程也有就绪、阻塞、运行三种基本状态
5. 线程几乎不拥有系统资源
6. 同一进程的不同线程之间共享进程的资源
7. 由于共享内存地址空间，同一进程中的线程通信甚至无需系统干预
8. 同一进程中的线程切换，不会引起进程切换；只有属于不同进程的线程切换才会引起进程切换。总的系统开销是减小了。


### 线程的实现方式
#### 用户级线程
背景：早期Unix只支持进程不支持线程，因此当时的线程是由线程库实现的。
实现过程：所有的线程管理工作（包括线程切换）都由应用程序完成，不经过操作系统干预。也就是说，这里的线程是仅能从用户视角看到的线程，从操作系统内核看来是不存在线程的。
|--|--|
|--|--|
|优点|用户级线程的切换在用户空间即可完成，不需要切换到核心态，系统开销小、效率高|
|缺点|当一个用户级线程被阻塞后，整个进程都会被阻塞，且由于分配资源的单位还是进程，因此多个线程不能在多核处理机上并行运行|

#### 内核支持的线程
此时从操作系统内核视角可以看到线程，线程的管理工作由操作系统内核来完成。
|--|--|
|--|--|
|优点|当一个线程被阻塞后，其他线程还可以继续执行。多线程可以在多核处理机上并行执行|
|缺点|一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成、需要切换到核心态，因此线程管理成本高、开销大|


### 多线程模型
#### 一对一模型
一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程相同数量的内核级线程。
|--|--|
|--|--|
|优点|当一个线程被阻塞后，其他线程还可以继续执行。多线程可以在多核处理机上并行执行|
|缺点|一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成、需要切换到核心态，因此线程管理成本高、开销大|

#### 多对一模型
多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程。
**相当于退化成用户级线程的方式**。
|--|--|
|--|--|
|优点|用户级线程的切换在用户空间即可完成，不需要切换到核心态，系统开销小、效率高|
|缺点|当一个用户级线程被阻塞后，整个进程都会被阻塞，且由于分配资源的单位还是进程，因此多个线程不能在多核处理机上并行运行|

#### 多对多
n个用户级线程映射到m个内核级线程（**n>=m**），这n个用户级线程属于同一个用户进程，而每个用户进程对应着m个内核级线程。
每个内核级线程可以运行任意一个与其有映射关系的用户级线程，而只有属于同一个进程的多个内核级线程在执行的用户级线程都阻塞的时候，这个进程才会阻塞。
|--|--|
|--|--|
|总结|克服了多对一模型并发度不高的缺点，又克服了一对一模型一个开销太大的缺点|


### 线程的状态和转换
只关注就绪、运行、阻塞三个状态。与进程的状态及其转换可谓一模一样。


### 调度的概念
由于资源有限，对于大量任务无法同时处理。此时就需要规则来决定处理任务的顺序。这个规则就是调度。
进程的挂起：当队列中有处理不完的进程时，优先级较低的进程就会被调入外存延缓执行，俗称挂起。

|--|做咩|调度发生位置|发生频率|对进程状态的影响|
|--|--|--|--|--|
|高级调度<br>作业调度|按照某种规则，从后备队列中选择合适的作业并将其调入内存，为其创建进程|外存->内存（面向作业）|最低|无->创建态->就绪态|
|中级调度<br>内存调度|按照某种规则，从挂起队列中选择合适的进程将其数据调回内存|外存->内存（面向进程）|中等|挂起态->就绪态<br>阻塞挂起->阻塞态|
|低级调度<br>进程调度|按照某种规则，从就绪队列中选择一个进程为其分配处理机|内存->CPU|最高|就绪态->运行态|

需要进行进程调度的时机：
进程主动放弃处理机：
1. 进程正常终止
2. 运行过程中发生异常而终止
3. 主动请求阻塞

进程被动放弃处理机：
1. 时间片用完
2. 有更紧急的事要处理（如IO中断）
3. 有更高优先级的进程进入就绪队列
   
不能进行进程调度的时机：在处理中断的过程中、在操作系统内核程序临界区中（如访问存在于内核中的进程的就绪队列）、在原语中。


### 进程同步和进程互斥
进程同步也叫直接制约关系，指的是为了完成某个任务而创建的两个及以上个进程，这些进程在某些位置上需要协调它们的工作次序而产生的制约关系。
临界资源：一个时间段内只允许一个进程使用的资源。
进程互斥指的是，当一个进程访问某个临界资源时，另一个想要访问该临界资源的进程必须等待，直到当前访问临界资源的进程访问结束并释放该资源。

### 进程互斥的要求
1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
2. 忙则等待。当已有进程进入临界区时，其他请求进入临界区的进程必须等待。
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区，保证不会饥饿。
4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

#### 单标志法
每个进程在自己使用后就把标志位设为下一个要使用临界资源的进程的唯一标识。
当某个资源连续两次需要访问临界资源时，就违反了“空闲让进”的规则。

#### 双标志先检查法
用一个布尔数组来标记各进程进入临界区的意愿。每个进程在进入临界区之前先检查当前是否有别的资源想进入临界区，有的话就循环等待，没有的话自己直接进。
由于每个进程的“检查”和“上锁”之间不是原子操作，当进程A检查通过后，没来得及上锁之前切换到进程B，此时进程B的检查也能通过，这就违反了“忙则等待”的规则。

#### 双标志后检查法
把上个方法的“检查”和“上锁”换了个位置。
由于每个进程的“检查”和“上锁”之间不是原子操作，当进程A上锁之后，没来得及检查之前切换到进程B，此时进程B也上了锁，那么接下来两个进程的检查都不通过，这就违反了“空闲让进”和“有限等待”的原则。


### 信号量
用一个整数型的变量作为**整形信号量**，用来表示系统中某种资源的数量。**对信号量的操作只有三种：初始化、P操作、V操作**。
P操作和V操作都是原子操作，P操作中把“检查”和“上锁”不中断地完成。
**记录形信号量**是一个结构体，包含一个整形变量和一个等待队列。对信号量进行一个P操作意味着进程请求一个单位的该类资源，因此需要执行信号量内的整形减一，即资源数减一。当整形<0时意味着该类资源分配完毕，因此这个进程应该进入阻塞队列，主动放弃CPU，这就实现了“让权等待”。

### 连续分配管理
**内部碎片**：分配给某进程的内存区域中，有些部分没用上，就叫做内部碎片。
**外部碎片**：是指内存中的某些空闲分区由于太小而难以利用。
#### 单一连续分配
只支持单道程序，内存分为系统区和用户区，用户程序放在用户区。
无外部碎片，有内部碎片。
#### 固定分区分配
支持多道程序，内存用户空间分为若干个固定大小的分区（分区大小可能相等也可能不相等），每个分区只能装一道作业。
无外部碎片，有内部碎片。
#### 动态分区分配
支持多道程序，这种分配方式不会预先划分内存分区，在进程装入程序时，根据进程的大小动态建立分区。
无内部碎片，有外部碎片。

### 动态分区分配算法
#### 首次适应
空闲分区以地址递增次序排列，每次从头到尾找合适的分区。
回收分区后一般不需要对空闲分区队列进行重新排列，算法开销小。
#### 最佳适应
空闲分区以容量递增次序排列，优先使用更小的分区，以保留更多大分区。
回收分区就要重新排序，算法开销大；而且会产生很多太小的难以利用的外部碎片。
#### 最坏适应
空闲分区以容量递减次序排列，优先使用更大的分区，防止产生太大太小的碎片。
回收分区就要重新排序，算法开销大；而且大分区容易很快被用完，不利于大进程。
#### 邻近适应
空闲分区以地址递增次序排列，可以排列成循环链表。由首次适应算法进化来，每次从上次查找结束位置开始查找。
回收分区后一般不需要对空闲分区队列进行重新排列，算法开销小；但会让高地址大分区先被用完。


### 虚拟内存
多次性，作业分成多次调入内存；对换性，作业运行过程中可以被换入换出；虚拟性，从逻辑上扩充了内存的容量。